"0","#######################################################################"
"0","### Function for predicting preference shares from a MNL model with ### "
"0","### bootstrap percentiles prediction intervals                      ### "
"0","#######################################################################"
"0",""
"0","# model: mlogit object returned by mlogit()"
"0","# data: a data frame containing the set of designs for which you want to "
"0","#       predict shares.  Same format of the data used to estimate model. "
"0","# nsim: number of bootstrap samples, default is 500"
"0","# conflevel: desired confidence level, default is 0.95"
"0","# nresp: number of representative respondents, default is 1000"
"0","# library ""parallel"" is necessary"
"0",""
"0","BootCI.predict.mixed.mnl <- function(model, data, nsim=500, conflevel=0.95, nresp=1000) {"
"0","dataModel <- model$model"
"0","dataModel$probabilities <- NULL"
"0","dataModel$linpred <- NULL"
"0","idx <- dataModel$idx "
"0","dataModel$idx <- NULL"
"0","dataModel <- data.frame(dataModel, idx)"
"0","idVar <- unique(dataModel[,names(idx)[1]])"
"0",""
"0","bootstrapping <- function(x) {"
"0","  idbootsamp <- data.frame(sample(idVar, replace=T))"
"0","  names(idbootsamp) <- names(idx)[1]"
"0","  bootsamp <- merge(idbootsamp, dataModel, by=names(idx)[1], all.x=T)"
"0","  bootsamp[,names(idx)[1]] <- rep(1:length(table(idx[,1])), each=length(table(idx[,3])))"
"0","  bootsamp.mlogit  <- dfidx(bootsamp, idx = list(c(names(idx)[1:2]), names(idx)[3]),"
"0","                            drop.index=F)    "
"0","  bootfit <- update(model, data = bootsamp.mlogit)"
"0","  data.model <- model.matrix(update(bootfit$formula, 0 ~ .), data = data)[,-1]"
"0","  coef.Sigma <- cov.mlogit(bootfit)"
"0","  coef.mu <- bootfit$coef[1:dim(coef.Sigma)[1]]"
"0","  draws <- mvrnorm(n=nresp, coef.mu, coef.Sigma)"
"0","  shares <- matrix(NA, nrow=nresp, ncol=nrow(data))"
"0","  for (i in 1:nresp) {"
"0","    utility <- data.model%*%draws[i,]"
"0","    share <- exp(utility)/sum(exp(utility))"
"0","    shares[i,] <- share"
"0","  }"
"0","  colMeans(shares)"
"0","}"
"0",""
"0","cl <- makeCluster(detectCores())"
"0","  clusterEvalQ(cl, {"
"0","                library(mlogit)"
"0","                library(MASS) })"
"0","  clusterExport(cl, varlist=c(""idVar"", ""dataModel"", ""idx"", ""model"", ""data"", ""nresp"", "
"0","                paste(model$call$rpar)), envir=environment())"
"0","  bootdistr <- parLapply(cl, 1:nsim, fun=bootstrapping)"
"0","stopCluster(cl)"
"0",""
"0","bootdistr <- do.call(cbind, bootdistr)"
"0","lowl <- (1-conflevel)/2"
"0","upl <- 1-lowl  "
"0","bootperc <- t(apply(bootdistr, 1, function(x) quantile(x, probs=c(lowl, upl))))"
"0","pointpred <- predict.mixed.mnl(model, data, nresp)"
"0","predictedShares <- cbind(pointpred[,1], bootperc, pointpred[,2:ncol(pointpred)])"
"0","names(predictedShares)[1] <- ""share"" "
"0","predictedShares"
"0","}"
